{"name":"Ms-numpress","tagline":"Implementations of two compression schemes for numeric data found from mass spectrometers.  ","body":"MS Numpress\r\n===========\r\n\r\nImplementations of two compression schemes for numeric data from mass spectrometers.\r\n\r\nThe library provides implementations of 3 different algorithms, \r\n1 designed to compress first order smooth data like retention \r\ntime or M/Z arrays, and 2 for compressing non smooth data with\r\nlower requirements on precision like ion count arrays.\r\n\r\nImplementations and unit test are provided in `c++` and `java`.\r\n\r\nNumpress Pic\r\n------------\r\n### MS Numpress positive integer compression\r\n\r\nIntended for ion count data, this compression simply rounds values \r\nto the nearest integer, and stores these integers in a truncated \r\nform which is effective for values relatively close to zero. \r\n\r\n\r\nNumpress Slof\r\n-------------\r\n### MS Numpress short logged float compression\r\n\r\nAlso targeting ion count data, this compression takes the natural\r\nlogarithm of values, multiplies by a scaling factor and rounds to \r\nthe nearest integer. For typical ion count dynamic range these values \r\nfits into two byte integers, so only the two least significant bytes \r\nof the integer are stored.\r\n\r\nThe scaling factor can be chosen manually, but the library also contains\r\na function for retrieving the optimal Slof scaling factor for a given data array.\r\nSince the scaling factor is variable, it is stored as a regular double \r\nprecision float first in the encoding, and automatically parsed during decoding.\r\n\r\nNumpress Lin\r\n------------\r\n### MS Numpress linear prediction compression\r\n\r\nThis compression uses a fixed point repressentation, achieve by \r\nmultiplication by a scaling factor and rounding to the nearest integer. \r\nTo exploit the assumed linearity of the data, linear prediction is \r\nthen used in the following way. \r\n\r\nThe first to values are stored without compression as 4 byte integers.\r\nFor each following value a linear predicion is made from the two previous\r\nvalues:\r\n\r\n\tXpred \t= (X(n) - X(n-1)) + X(n)\r\n\tXres \t= Xpred - X(n+1)\r\n\r\nThe residual `Xres` is then stored, using the same truncated integer \r\nrepresentation as in Numpress Pic.  \r\n\r\nThe scaling factor can be chosen manually, but the library also contains\r\na function for retrieving the optimal Lin scaling factor for a given data array.\r\nSince the scaling factor is variable, it is stored as a regular double \r\nprecision float first in the encoding, and automatically parsed during decoding.\r\n\r\nTruncated integer representation \r\n---------------------------------\r\n\r\nThis encoding works on a 4 byte integer, by truncating initial zeros or ones.\r\nIf the initial (most significant) half byte is 0x0 or 0xf, the number of such \r\nhalfbytes starting from the most significant is stored in a halfbyte. This initial \r\ncount is then followed by the rest of the ints halfbytes, in little-endian order. \r\nA count halfbyte c of\r\n\r\n\t0 <= c <= 8 \t\tis interpreted as an initial c \t\t0x0 halfbytes\r\n\t9 <= c <= 15\t\tis interpreted as an initial (c-8) \t0xf halfbytes\r\n\r\nExamples:\r\n\r\n\tint\t\tc\t\trest\r\n\t0 \t=> \t0x8\r\n\t-1\t=>\t0xf\t\t0xf\r\n\t23\t=>\t0x6 \t0x7\t0x1\r\n\r\n\r\n\r\nLicense \r\n-------\r\n\r\nThis code is open source. By default code is licenses with the Apache 2.0 license. \r\nIf you for some reason prefer BSD, there is a version which is BSD 3-clause licensed \r\nin the src/bsd directory.  \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}